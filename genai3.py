# -*- coding: utf-8 -*-
"""GenAi3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o8MzieOwYiUnePLvux_VULSY-nXKbo0E
"""

pip install pandas openpyxl

pip install google-generativeai PyGithub

import os
import time
import re
import pandas as pd
from github import Github
import google.generativeai as genai

REPO_NAME = "NibirDas13/GenAi"
SLEEP_BETWEEN_FILES = 1
TARGET_FILE = "REPORT.TXT"
EXCEL_FILE = "PR_REPORT.xlsx"

def configure_gemini():
    genai.configure(api_key="AIzaSyD9UjF9NK4iyuik5j94nYfbbZpBa-VZ2m0")
    return genai.GenerativeModel("gemini-2.5-flash")

def get_github_repo():
    g = Github("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")
    return g.get_repo(REPO_NAME)

def analyze_code_diff(model, filename, diff_text):
    if not diff_text.strip():
        return None

    prompt = f"""
    Objective: Critically review the provided C# Aras Innovator Method code for optimization, security, error handling, and adherence to Aras best practices.

Core Review Focus Areas:

Optimization (Data Fetching):

Verify all ApplyAML and ApplySQL methods use the select attribute or SELECT columns explicitly to retrieve only the necessary properties/fields. Flag any use of SELECT * or AML without a specified select attribute.

Ensure all data access logic is wrapped in a robust try/catch block.

Verify that Aras-specific error checking (isError()) is used immediately after API calls, and custom exceptions are thrown or logged appropriately.

Verify that any returned Aras Item is either valid data or a new error item (serverItem.newError(...)).

General C# & Aras Best Practices:

Flag complex logic or inefficient loops.

Required Output Format:

generate a numbered list (1, 2, 3...) of specific critiques. Each item in the list MUST be a single line containing:

The line number where the issue or suggested change resides.

A concise critique/suggestion phrase of exactly 3 to 5 words.

BUT IF NOT RELATED TO ARAS INNOVATOT JUST RETURN ONE SINGLE LINE "NOT RELATED TO ARAS INNOVATOR"

Example Critique Line Format:
LINE 16 Add finally block for cleanup.
LINE 8 Parameterize AML to prevent injection.

    Return structured JSON with these fields:
    {{
        "aras_related": true/false,
        "compliance_percentage": 0-100,
        "time_complexity": "O(n)",
        "space_complexity": "O(1)",
        "non_compliance_issues": ["LINE 16 Add finally block...", ...]
    }}

    If NOT related to Aras Innovator, return:
    {{"aras_related": false}}

    Code to analyze:
    {diff_text}
    """
    try:
        response = model.generate_content(prompt)
        text = response.text.strip()

        # Try to extract JSON content (Gemini often outputs valid JSON)
        json_match = re.search(r"\{.*\}", text, re.DOTALL)
        if json_match:
            import json
            return json.loads(json_match.group(0))
        else:
            return {"aras_related": False, "raw_output": text}
    except Exception as e:
        print(f"‚ö†Ô∏è Error analyzing {filename}: {e}")
        return None

"""| *1. Optimization & Performance*    | *25 %* | Efficient AML/SQL usage, no SELECT *, minimal repeated DB calls.              |

| *2. Error Handling & Robustness*   | *25 %* | Proper try/catch, use of isError(), error logging, finally blocks.        |

| *3. Security & Validation*         | *20 %* | No input concatenation, sanitized parameters, no hard-coded credentials.        |

| *4. C# Code Quality*               | *15 %* | Readable structure, consistent naming, efficient loops, correct typing.         |

| *5. Aras Innovator Best Practices* | *15 %* | Correct use of Innovator, valid thisItem return, proper error/log handling. |


*Compliance % = Sum of weighted scores across all five categories*
"""

def analyze_pull_request(repo, model, pr):
    print(f"\nüîç Processing PR #{pr.number}: {pr.title}")
    results = []

    for file in pr.get_files():
        if not file.filename.endswith(".cs"):
            continue
        print(f"üìÑ Analyzing {file.filename}")
        result = analyze_code_diff(model, file.filename, file.patch or "")
        if result:
            results.append({
                "PR Number": pr.number,
                "PR Title": pr.title,
                "Developer Name": pr.user.login if pr.user else "Unknown",
                "File Name": file.filename,
                "Compliance %": result.get("compliance_percentage", 0),
                "Time Complexity": result.get("time_complexity", ""),
                "Space Complexity": result.get("space_complexity", ""),
                "Non-Compliance Details": "; ".join(result.get("non_compliance_issues", [])),
                "Aras Related": result.get("aras_related", True)
            })
        time.sleep(SLEEP_BETWEEN_FILES)
    return results

def analyze_all_open_prs():
    repo = get_github_repo()
    model = configure_gemini()
    open_prs = repo.get_pulls(state="open", sort="created")
    all_results = []

    for pr in open_prs:
        pr_results = analyze_pull_request(repo, model, pr)
        all_results.extend(pr_results)

    if all_results:
        df = pd.DataFrame(all_results)
        df.to_excel(EXCEL_FILE, index=False)
        print(f"‚úÖ Excel report generated: {EXCEL_FILE}")
    else:
        print("‚ÑπÔ∏è No PR data to write.")

if __name__ == "__main__":
    analyze_all_open_prs()

